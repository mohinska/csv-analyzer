# Agent Design Decisions

All decisions discussed and agreed upon during development.

## Architecture: LangGraph

### State Schema

```python
class AgentState(TypedDict):
    messages: list          # Anthropic-format messages (full conversation)
    session_id: str
    file_path: str          # data/{session_id}/original.csv
    file_metadata: dict     # { columns, row_count, col_count, column_types }
    is_initial_analysis: bool
    should_stop: bool       # set True when user sends "stop"
```

### Graph Topology

```
START → planner → [conditional] → execute_tools → planner (loop)
                       ↓
                      END (when finalize called, or should_stop)
```

**Two nodes:**
- `planner` — Calls Claude with (system prompt + messages + tool definitions). Returns assistant message with reasoning text + tool_use blocks.
- `execute_tools` — Iterates over tool_use blocks, executes each, streams results via WS, appends tool_result messages.

**Conditional edge after planner:**
- If tool calls include `finalize` → END
- If `should_stop` is True → END
- Otherwise → `execute_tools`

**Edge after execute_tools:**
- Always → back to `planner`

### Two Flows, One Agent

| Flow | Trigger | System Prompt |
|------|---------|---------------|
| Initial analysis | `{ type: "auto_analyze" }` | Prompt 1 |
| User question | `{ type: "message", text: "..." }` | Prompt 2 |

## Data Access

DuckDB view created per connection:
```sql
CREATE VIEW data AS SELECT * FROM read_csv_auto('/path/to/file.csv')
```
Agent always queries `SELECT ... FROM data`.

## Tools (5)

### sql_query
- Params: `query` (str), `description` (str)
- Executes DuckDB SELECT. Only SELECT/WITH allowed, all DML/DDL blocked.
- Returns columns + rows (truncated) as tool_result.
- Streams `query_result` event to frontend.

### output_text
- Params: `text` (str, markdown)
- Streams `text` event to frontend.

### output_table
- Params: `title` (str), `headers` (list[str]), `rows` (list[list])
- Streams `table` event to frontend.
- Frontend shows preview (5 rows) + expand for larger tables.

### create_plot
- Params: `title` (str), `vega_lite_spec` (object)
- Vega-Lite v5 spec with data included inline as `data.values`.
- Agent must aggregate via sql_query first, max 100 rows in data.values (enforced server-side).
- Streams `plot` event to frontend.

### finalize
- Params: `session_title` (str | null)
- Ends the turn. Sets session title after auto_analyze, null otherwise.
- Streams `done` event to frontend.

## Reasoning Steps

- Claude outputs text alongside tool_use blocks — this is the reasoning.
- Saved to DB: `role="assistant"`, `type="reasoning"`.
- NOT streamed to frontend.
- Included in LLM context for all future turns.

## Parallel Tool Calls

Allowed. Claude can return multiple tool_use blocks. Executed sequentially, each streamed independently.

## WebSocket Events

### Server → Client

| Event | Payload |
|-------|---------|
| `status` | `{ message: str }` |
| `text` | `{ text: str }` |
| `table` | `{ title: str, headers: list[str], rows: list[list] }` |
| `plot` | `{ title: str, vega_lite_spec: object }` |
| `query_result` | `{ description: str, query: str, columns: list[str], rows: list[list], row_count: int, is_error: bool }` |
| `session_update` | `{ title: str }` |
| `error` | `{ message: str }` |
| `done` | `{ data_updated: bool }` |

### Client → Server

| Type | Payload |
|------|---------|
| `message` | `{ type: "message", text: str }` |
| `auto_analyze` | `{ type: "auto_analyze" }` |
| `stop` | `{ type: "stop" }` |

## Message DB Persistence

| Tool | `role` | `type` | `text` | `plot_data` |
|------|--------|--------|--------|-------------|
| output_text | assistant | text | the text | null |
| output_table | assistant | table | title | JSON { headers, rows } |
| create_plot | assistant | plot | title | JSON { title, vega_lite_spec } |
| sql_query | assistant | query_result | description | JSON { query, columns, rows, row_count } |
| reasoning | assistant | reasoning | reasoning text | null |
| user msg | user | text | the text | null |

## Session Title

Generated by the agent via `finalize(session_title=...)` after auto_analyze only.

## Prompts

### Prompt 1 — Initial Analysis

```
You are a data analyst. The user just uploaded a dataset. Your job is to explore it and provide a concise initial analysis.

{data_summary_block}

Your task:
1. Use sql_query to explore the data — check sample values, null counts, distributions, unique counts, and basic statistics for key columns.
2. Based on your findings, produce exactly two outputs:
   a. output_text: A concise summary (3-5 sentences) of what this dataset is about and the most important insights or patterns you found.
   b. output_table: A per-column analysis table with these columns: Column, Type, Non-Null Count, Unique Count, Description, Typical Values, Issues. Cover every column in the dataset.
3. Call finalize with a short descriptive session title (e.g. "E-commerce Sales Q4 2024", "Customer Churn Analysis").

Guidelines:
- Run as many sql_query calls as needed to understand the data before writing your analysis.
- Keep the summary concise — highlight what matters, skip the obvious.
- In the per-column table, "Issues" should flag: high null rates, suspicious outliers, mixed types, constant columns, etc. Write "None" if clean.
- Only SELECT queries are allowed. Never attempt to modify data.
```

### Prompt 2 — User Question

```
You are a data analyst assistant. You help the user explore and understand their dataset through conversation.

{data_summary_block}

You have access to tools for querying data, creating visualizations, and presenting results. Use them as needed to answer the user's question thoroughly.

Guidelines:
- Use sql_query to fetch the data you need before answering. Don't guess — verify with queries.
- When presenting numbers or results, show your work: run the query, then explain the findings.
- For visual questions (distributions, trends, comparisons), prefer create_plot with a Vega-Lite spec.
- For tabular results, use output_table for structured data.
- Use output_text for explanations, insights, and narrative.
- You may call multiple tools in one step if needed.
- Call finalize when you've fully answered the question (pass null for session_title).

Constraints:
- Only SELECT queries are allowed. Never attempt to modify data.
- Stay on topic — only discuss this dataset and data analysis. Politely decline unrelated requests.
- If the user's question is ambiguous, make a reasonable interpretation and state your assumption.
- If a query fails, examine the error, adjust, and retry. Don't give up on the first failure.
```

### Data Summary Block (injected dynamically)

```
## Dataset
Table: `data`
Rows: {row_count}
Columns ({col_count}):
  - {col_name}: {col_type}
  ...
```

## Context Size

Deferred — no truncation/summarization strategy for now. Will address when needed.

## Dependencies (new)

- `anthropic` — Claude API SDK
- `langgraph` — Agent graph framework
- `pytest` + `pytest-asyncio` — Testing
